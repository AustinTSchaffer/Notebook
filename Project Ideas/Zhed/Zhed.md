---
tags: Journal, AI, Games
---
# Zhed

## Overview
I'm currently playing around with this game called Zhed. Zhed is a tile-laying puzzle game, played on a square grid, with stacks of tiles scattered around the board. Each stack of tiles has a number on top, corresponding to the number of tiles that can be moved from that cell in one of the orthogonal directions. When moved, all of the tiles must be moved in the same direction. When placing tiles, if there is a tile in the way, you skip over that cell and place the tile on the other side. If there's a run of tiles in the way, you place the tile at the end of the run of tiles.

The objective is to cover a specific cell with a tile.

## Example Levels
![[Zhed Example Level 1.png]]

![[Zhed Example Level 2.png]]

## Complexity
In the worst case, the player can make one of 5 moves from each tile stack:
- Lay tiles north
- Lay tiles south
- Lay tiles east
- Lay tiles west
- Do nothing

In the majority of cases, you do end up performing an action against all of the stacks. Therefore the "do nothing" step can probably be omitted from calculating the upper limit on the number of possible *move sequences*. However it should be considered when calculating the upper limit on the number of possible board states.

For a formal language definition, we can describe a move using the format `sND`, where
- `s` is constant, shorthand for "stack"
- `N` numerically identifies one of the stacks on the board, using an integer
- `D` identifies the cardinal direction that the stack should be moved: `n`, `s`, `e`, or `w`

We can then describe a move sequence as a list of moves. For example: `[s1n, s3s, s13w, s2e]` describes moving stack 1 north, stack 3 south, stack 13 west, and stack 2 east. You can then also describe all possible move sequences as a list of move sequences.


- For a board with 1 stack, there are 4 possible moves, and 5 possible board states.
	- 1 x 0-move sequences: `[[]]`
	- 4 x 1-move sequences: `[[s1n], [s1s], [s1e], [s1w]]`
- For a board with 2 stacks
	- there are 5 possible moves you can make with each stack
	- the order in which you perform those moves from each stack matters, given that one moves from one can influence the other
	- On some boards, some of these sequences will result in identical board states, some of these sequences will result in unique boards.
	- On most boards, the minimum number of moves required to solve the puzzle will equal the number of stacks.
	- possible move sequences (41 in total):
		- 1 x 0-move sequences: `[[]]`
		- 4 x 1-move sequences starting with stack 1 (s1): `[[s1n], [s1s], [s1e], [s1w]]`
		- 4 x 1-move sequences starting with stack 2 (s2): `[[s2n], [s2s], [s2e], [s2w]]`
		- 16 x 2-move sequences starting with s1:
			- `[[s1n, s2n], [s1n, s2s], [s1n, s2e], [s1n, s2w], [s1s, s2n], [s1s, s2s], [s1s, s2e], [s1s, s2w], [s1e, s2n], [s1e, s2s], [s1e, s2e], [s1e, s2w], [s1w, s2n], [s1w, s2s], [s1w, s2e], [s1w, s2w]]`
			- Shorthand: 16 x s1->s2
		- 16 x 2-move sequences starting with s2:
			- `[[s2n, s1n], [s2n, s1s], [s2n, s1e], [s2n, s1w], [s2s, s1n], [s2s, s1s], [s2s, s1e], [s2s, s1w], [s2e, s1n], [s2e, s1s], [s2e, s1e], [s2e, s1w], [s2w, s1n], [s2w, s1s], [s2w, s1e], [s2w, s1w]]`
			- Shorthand 16 x s2->s1
- For a board with 3 stacks
	- possible move sequences
		- 1 x 0-move sequences
		- 4 x 1-move sequences for s1
		- 4 x 1-move sequences for s2
		- 4 x 1-move sequences for s3
		- 2-move sequences starting with s1
			- 16 x s1->s2
			- 16 x s1->s3
		- 2-move sequences starting with s2
			- 16 x s2->s1
			- 16 x s2->s3
		- 2-move sequences starting with s3
			- 16 x s3->s1
			- 16 x s3->s2
		- 3-move sequences starting with s1
			- 16x4 x s1->s2->s3
			- 16x4 x s1->s3->s2
		- 3-move sequences starting with s2
			- 16x4 x s2->s1->s3
			- 16x4 x s2->s3->s1
		- 3-move sequences starting with s3
			- 16x4 x s3->s2->s1
			- 16x4 x s3->s1->s2
	- In total there are 493 possible move sequences.

Starting to see a pattern emerge. Plugging the sequence `[5, 41, 493]` into the online encyclopedia of integer sequences (OEIS) yields: https://oeis.org/A056545, which shows the sequence of numbers generated by the recursive equation $f(n)=(4n)f(n-1)+1$ with $f(0)=1$. This pattern holds for 4 terms. Can we prove that it holds for all n?

Let's break this down a little bit. There's a couple of ways of thinking about this.
- For a board that contains $n$ stacks, there are $n!$ permutations of those stacks
- For each stack, you can perform 5 different moves. (nothing, up, down, left, right). Including "nothing" in this list normalizes all move sequences as being length $n$
- The number of move sequences under this scheme would be $n!5^n$, which is equivalent to $\prod_{i=1}^{n} 5*(n-i+1)$. Verbally,
	- $n$ choices for the first stack, 5 choices for that stack's move. 
	- $n-1$ choices for the second stack, 5 choices for that stack's move. 
	- $...$
	- 1 choice for the last stack, 5 choices for that stack's move.
- This will count some sequences more than once. For example `[s2_, s1n]` is equivalent to `[s1n, s2_]`. There does not appear to be an easy divisor for fixing this.

Alternatively
- Each move affects a single stack.
- Take only the move sequences which affect stack 1, then stack 2, then stack 3. There are 4 possible actionable moves for each stack. There are $4^M$ move sequences that fit this category. We will call this a "stack sequence".
- A board with $N$ stacks has move sequences of length 0 to length $N$
- The number of stack sequences of length $K$ is a permutation of $N$, given by the equation $^nP_k=\frac{n!}{(n-k)!}$.
- $\sum_{x=0}^{N}\frac{N!}{(N-x)!}4^x$
- This equation also appears to produce the same results as the OEIS equation.


Given the set of all move sequences for a board of size n, you can generate the move sequences for a board of size (n+1) using the following algorithm.
- For each move sequence in a board of size $n$
	- For each of the positions in the move sequence
		- Generate 4 new move sequences using the new stack
- Copy all of the move sequences from a board of size n.

The 0th case is interesting, it implies that a board with 0 stacks has 1 possible move sequence, the "do nothing" move sequence (`[]`).

## Strategy
This game clearly relies on strategy to reduce the search space.

- Moving a stack into a region where it does not have influence over another stack is not a useful move.
- 


