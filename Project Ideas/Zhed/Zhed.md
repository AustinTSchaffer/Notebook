---
tags: Journal, AI, Games
---
# Zhed

## Overview
I'm currently playing around with this game called Zhed. Zhed is a tile-laying puzzle game, played on a square grid, with stacks of tiles scattered around the board. Each stack of tiles has a number on top, corresponding to the number of tiles that can be moved from that cell in one of the orthogonal directions. When moved, all of the tiles must be moved in the same direction. When placing tiles, if there is a tile in the way, you skip over that cell and place the tile on the other side. If there's a run of tiles in the way, you place the tile at the end of the run of tiles.

The objective is to cover a specific cell with a tile.

## Example Levels
### Example 1
![[Zhed Example Level 1.png]]

In this example level, the top-most stack of 2 tiles is the only stack which is in-line with the goal cell.

### Example 2
![[Zhed Example Level 2.png]]

## Complexity
In the worst case, the player can make one of 5 moves from each tile stack:
- Lay tiles north
- Lay tiles south
- Lay tiles east
- Lay tiles west
- Do nothing

In the majority of cases, you do end up performing an action against all of the stacks. Therefore the "do nothing" step can probably be omitted from calculating the upper limit on the number of possible *move sequences*. However it should be considered when calculating the upper limit on the number of possible board states.

For a formal language definition, we can describe a move using the format `sND`, where
- `s` is constant, shorthand for "stack"
- `N` numerically identifies one of the stacks on the board, using an integer
- `D` identifies the cardinal direction that the stack should be moved: `n`, `s`, `e`, or `w`

We can then describe a move sequence as a list of moves. For example: `[s1n, s3s, s13w, s2e]` describes moving stack 1 north, stack 3 south, stack 13 west, and stack 2 east. You can then also describe all possible move sequences as a list of move sequences.


- For a board with 1 stack, there are 4 possible moves, and 5 possible board states.
	- 1 x 0-move sequences: `[[]]`
	- 4 x 1-move sequences: `[[s1n], [s1s], [s1e], [s1w]]`
- For a board with 2 stacks
	- there are 5 possible moves you can make with each stack
	- the order in which you perform those moves from each stack matters, given that one moves from one can influence the other
	- On some boards, some of these sequences will result in identical board states, some of these sequences will result in unique boards.
	- On most boards, the minimum number of moves required to solve the puzzle will equal the number of stacks.
	- possible move sequences (41 in total):
		- 1 x 0-move sequences: `[[]]`
		- 4 x 1-move sequences starting with stack 1 (s1): `[[s1n], [s1s], [s1e], [s1w]]`
		- 4 x 1-move sequences starting with stack 2 (s2): `[[s2n], [s2s], [s2e], [s2w]]`
		- 16 x 2-move sequences starting with s1:
			- `[[s1n, s2n], [s1n, s2s], [s1n, s2e], [s1n, s2w], [s1s, s2n], [s1s, s2s], [s1s, s2e], [s1s, s2w], [s1e, s2n], [s1e, s2s], [s1e, s2e], [s1e, s2w], [s1w, s2n], [s1w, s2s], [s1w, s2e], [s1w, s2w]]`
			- Shorthand: 16 x s1->s2
		- 16 x 2-move sequences starting with s2:
			- `[[s2n, s1n], [s2n, s1s], [s2n, s1e], [s2n, s1w], [s2s, s1n], [s2s, s1s], [s2s, s1e], [s2s, s1w], [s2e, s1n], [s2e, s1s], [s2e, s1e], [s2e, s1w], [s2w, s1n], [s2w, s1s], [s2w, s1e], [s2w, s1w]]`
			- Shorthand 16 x s2->s1
- For a board with 3 stacks
	- possible move sequences
		- 1 x 0-move sequences
		- 4 x 1-move sequences for s1
		- 4 x 1-move sequences for s2
		- 4 x 1-move sequences for s3
		- 2-move sequences starting with s1
			- 16 x s1->s2
			- 16 x s1->s3
		- 2-move sequences starting with s2
			- 16 x s2->s1
			- 16 x s2->s3
		- 2-move sequences starting with s3
			- 16 x s3->s1
			- 16 x s3->s2
		- 3-move sequences starting with s1
			- 16x4 x s1->s2->s3
			- 16x4 x s1->s3->s2
		- 3-move sequences starting with s2
			- 16x4 x s2->s1->s3
			- 16x4 x s2->s3->s1
		- 3-move sequences starting with s3
			- 16x4 x s3->s2->s1
			- 16x4 x s3->s1->s2
	- In total there are 493 possible move sequences.

Starting to see a pattern emerge. Plugging the sequence `[5, 41, 493]` into the online encyclopedia of integer sequences (OEIS) yields: https://oeis.org/A056545, which shows the sequence of numbers generated by the recursive equation $f(n)=(4n)f(n-1)+1$ with $f(0)=1$. This pattern holds for 4 terms. Can we prove that it holds for all n?

Let's break this down a little bit. There's a couple of ways of thinking about this.
- For a board that contains $n$ stacks, there are $n!$ permutations of those stacks
- For each stack, you can perform 5 different moves. (nothing, up, down, left, right). Including "nothing" in this list normalizes all move sequences as being length $n$
- The number of move sequences under this scheme would be $n!5^n$, which is equivalent to $\prod_{i=1}^{n} 5*(n-i+1)$. Verbally,
	- $n$ choices for the first stack, 5 choices for that stack's move. 
	- $n-1$ choices for the second stack, 5 choices for that stack's move. 
	- $...$
	- 1 choice for the last stack, 5 choices for that stack's move.
- This will count some sequences more than once. For example `[s2_, s1n]` is equivalent to `[s1n, s2_]`. There does not appear to be an easy divisor for fixing this.

Alternatively
- Each move affects a single stack.
- Take only the move sequences which affect stack 1, then stack 2, then stack 3. There are 4 possible actionable moves for each stack. There are $4^M$ move sequences that fit this category. We will call this a "stack sequence".
- A board with $N$ stacks has move sequences of length 0 to length $N$
- The number of stack sequences of length $K$ is a permutation of $N$, given by the equation $^nP_k=\frac{n!}{(n-k)!}$.
- $\sum_{x=0}^{N}\frac{N!}{(N-x)!}4^x$
- This equation also appears to produce the same results as the OEIS equation.

| Stacks | Board States (Upper Bound) | 
| ------:| --------------------------:|
|      0 |                          1 |
|      1 |                          5 |
|      2 |                         41 |
|      3 |                        493 |
|      4 |                      7,889 |
|      5 |                    157,781 |
|      6 |                  3,786,745 |
|      7 |                106,028,861 |
|      8 |              3,392,923,553 |
|      9 |            122,145,247,909 |
|     10 |          4,885,809,916,361 |

Given the set of all move sequences for a board of size n, you can generate the move sequences for a board of size (n+1) using the following algorithm.
- For each move sequence in a board of size $n$
	- For each of the positions in the move sequence
		- Generate 4 new move sequences using the new stack
- Copy all of the move sequences from a board of size n.

## Strategy
This game clearly relies on strategy to reduce the search space.

- Moving a stack into a region where it does not have influence over another stack is not a useful move.
- The tile stack which will cover the goal cell will lie on one of the 4 cardinal directions from the goal cell.
- The problem can be defined recursively.
	- You need to move one of the stacks that on one of the cardinal directions from the goal cell. That stack will be moved in the direction toward the goal cell.
	- If the stack is not tall enough to reach the goal, then it will need to calculate the number of tiles short that it is from the goal. Call this number $J$. At a minimum, $J$ tiles will need to be filled between the stack and the goal.
	- Pick one of the $J$ empty cells between the stack and the goal cell, designate that as a new goal, rewrite a new configuration of the level using its current state, then recurse on the solving algorithm.
	- If the stack requires that more than one tile is filled between itself and the goal, then the solver may need to play around with a few permutations of selecting $J$ tiles from the space between a stack and its goal.
	- At least one of the $J$ tiles must be within the current toppling distance of the stack. 
- To aid the recursive strategy, the solving algorithm needs to be able to communicate that a configuration is unsolvable.
- If there are no tiles in any of the cardinal directions from a goal cell, that is a super simple heuristic for determining that a configuration is unsolvable.
